# Code analysis
## CupCake 
#### Version 1.0-SNAPSHOT 

**By: Administrator**

*Date: 2019-10-28*

## Introduction
This document contains results of the code analysis of CupCake



## Configuration

- Quality Profiles
    - Names: Sonar way [Java]; Sonar way [JSP]; 
    - Files: AW4ScWgUSRN48LnyzVkj.json; AW4ScWtpSRN48LnyzVrm.json; 
 - Quality Gate
    - Name: Sonar way
    - File: Sonar way.xml

## Synthesis
Quality Gate | Reliability | Security | Maintainability | Coverage | Duplications
:---:|:---:|:---:|:---:|:---:|:---:
OK | E | B | A | 70.6 % | 1.8 %

## Metrics

\ | Cyclomatic Complexity | Cognitive Complexity | Lines of code per file | Coverage | Comment density (%) | Duplication (%)
:---|:---:|:---:|:---:|:---:|:---:|:---:
Min | 0.0 | 0.0 | 5.0 | 0.0 | 0.0 | 0.0
Max | 291.0 | 180.0 | 2512.0 | 100.0 | 62.5 | 20.0

## Volume

Language|Number
---|---
Java|1547
JSP|965
Total|2512


## Issues count by severity and types

Type|Severity|Number
---|---|---
VULNERABILITY|BLOCKER|0
VULNERABILITY|CRITICAL|0
VULNERABILITY|MAJOR|0
VULNERABILITY|MINOR|7
VULNERABILITY|INFO|0
BUG|BLOCKER|26
BUG|CRITICAL|0
BUG|MAJOR|39
BUG|MINOR|4
BUG|INFO|0
CODE_SMELL|BLOCKER|12
CODE_SMELL|CRITICAL|11
CODE_SMELL|MAJOR|26
CODE_SMELL|MINOR|59
CODE_SMELL|INFO|9
SECURITY_HOTSPOT|BLOCKER|0
SECURITY_HOTSPOT|CRITICAL|0
SECURITY_HOTSPOT|MAJOR|0
SECURITY_HOTSPOT|MINOR|0
SECURITY_HOTSPOT|INFO|0


## Issues
Name|Description|Type|Severity|Number
---|---|---|---|---
Resources should be closed|Connections, streams, files, and other classes that implement the Closeable interface or its super-interface, <br /> AutoCloseable, needs to be closed after use. Further, that close call must be made in a finally block otherwise <br /> an exception could keep the call from being made. Preferably, when class implements AutoCloseable, resource should be created using <br /> "try-with-resources" pattern and will be closed automatically. <br /> Failure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box it's on to <br /> their knees. <br /> Noncompliant Code Example <br />  <br /> private void readTheFile() throws IOException { <br />   Path path = Paths.get(this.fileName); <br />   BufferedReader reader = Files.newBufferedReader(path, this.charset); <br />   // ... <br />   reader.close();  // Noncompliant <br />   // ... <br />   Files.lines("input.txt").forEach(System.out::println); // Noncompliant: The stream needs to be closed <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     for (String property : propertyList) { <br />       stream = new FileOutputStream("myfile.txt");  // Noncompliant <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close();  // Multiple streams were opened. Only the last is closed. <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> private void readTheFile(String fileName) throws IOException { <br />     Path path = Paths.get(fileName); <br />     try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { <br />       reader.readLine(); <br />       // ... <br />     } <br />     // .. <br />     try (Stream&lt;String&gt; input = Files.lines("input.txt"))  { <br />       input.forEach(System.out::println); <br />     } <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     stream = new FileOutputStream("myfile.txt"); <br />     for (String property : propertyList) { <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close(); <br />   } <br /> } <br />  <br /> Exceptions <br /> Instances of the following classes are ignored by this rule because close has no effect: <br />  <br />    java.io.ByteArrayOutputStream  <br />    java.io.ByteArrayInputStream  <br />    java.io.CharArrayReader  <br />    java.io.CharArrayWriter  <br />    java.io.StringReader  <br />    java.io.StringWriter  <br />  <br /> Java 7 introduced the try-with-resources statement, which implicitly closes Closeables. All resources opened in a try-with-resources <br /> statement are ignored by this rule.  <br />  <br /> try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { <br />   //... <br /> } <br /> catch ( ... ) { <br />   //... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-459 - Incomplete Cleanup  <br />    CERT, FIO04-J. - Release resources when they are no longer needed  <br />    CERT, FIO42-C. - Close files when they are no longer needed  <br />    Try With Resources  <br /> |BUG|BLOCKER|25
"PreparedStatement" and "ResultSet" methods should be called with valid indices|The parameters in a PreparedStatement are numbered from 1, not 0, so using any "set" method of a PreparedStatement with a <br /> number less than 1 is a bug, as is using an index higher than the number of parameters. Similarly, ResultSet indices also start at 1, <br /> rather than 0 <br /> Noncompliant Code Example <br />  <br /> PreparedStatement ps = con.prepareStatement("SELECT fname, lname FROM employees where hireDate &gt; ? and salary &lt; ?"); <br /> ps.setDate(0, date);  // Noncompliant <br /> ps.setDouble(3, salary);  // Noncompliant <br />  <br /> ResultSet rs = ps.executeQuery(); <br /> while (rs.next()) { <br />   String fname = rs.getString(0);  // Noncompliant <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> PreparedStatement ps = con.prepareStatement("SELECT fname, lname FROM employees where hireDate &gt; ? and salary &lt; ?"); <br /> ps.setDate(1, date); <br /> ps.setDouble(2, salary); <br />  <br /> ResultSet rs = ps.executeQuery(); <br /> while (rs.next()) { <br />   String fname = rs.getString(1); <br />   // ... <br /> } <br /> |BUG|BLOCKER|1
"<!DOCTYPE>" declarations should appear before "<html>" tags|The &lt;!DOCTYPE&gt; declaration tells the web browser which (X)HTML version is being used on the page, and therefore how to interpret <br /> the various elements. <br /> Validators also rely on it to know which rules to enforce. <br /> It should always preceed the &lt;html&gt; tag. <br /> Noncompliant Code Example <br />  <br /> &lt;html&gt;  &lt;!-- Noncompliant --&gt; <br /> ... <br /> &lt;/html&gt; <br />  <br /> Compliant Solution <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html&gt;  &lt;!-- Compliant --&gt; <br /> ... <br /> &lt;/html&gt; <br /> |BUG|MAJOR|12
"<html>" element should have a language attribute|The &lt;html&gt;&nbsp;element should provide the lang and/or xml:lang attribute in order to identify the <br /> default language of a document. <br /> It enables assistive technologies, such as screen readers,&nbsp;to provide a comfortable reading experience by adapting the pronunciation and <br /> accent to the language. It also helps braille translation software, telling it to switch the control codes for accented characters for instance. <br /> Other benefits of marking the language include: <br />  <br />    assisting user agents in providing dictionary definitions or helping users benefit from translation tools.  <br />    improving search engine ranking. <br />    <br />  <br /> Both the lang and the xml:lang attributes can take only one value. <br /> &nbsp; <br /> Noncompliant Code Example <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html&gt; &lt;!-- Noncompliant --&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;head&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;title&gt;A page written in english&lt;/title&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;meta content="text/html; charset=utf-8" /&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;/head&gt; &nbsp; <br />  <br />  <br /> &nbsp;&nbsp;&nbsp; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; &lt;/body&gt; <br /> &lt;/html&gt; <br />  <br /> Compliant Solution <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html lang="en"&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;head&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;title&gt;A page written in english&lt;/title&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;meta content="text/html; charset=utf-8" /&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;/head&gt; &nbsp; <br />  <br />  <br /> &nbsp;&nbsp;&nbsp; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; &lt;/body&gt; <br /> &lt;/html&gt; <br />  <br />  <br /> &lt;!DOCTYPE html&gt; <br /> &lt;html lang="en" xml:lang="en"&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;head&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;title&gt;A page written in english&lt;/title&gt; <br />  &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;meta content="text/html; charset=utf-8" /&gt; <br /> &nbsp;&nbsp;&nbsp; &lt;/head&gt; &nbsp; <br />  <br />  <br /> &nbsp;&nbsp;&nbsp; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp; <br /> &nbsp;&nbsp;&nbsp; &lt;/body&gt; <br /> &lt;/html&gt; <br />  <br /> See <br />  <br />    WCAG2, H57 - Using language attributes on the html element  <br />    WCAG2, 3.1.1 - Language of Page  <br /> |BUG|MAJOR|12
"<th>" tags should have "id" or "scope" attributes|Associating &lt;table&gt; headers, i.e. &lt;th&gt; elements, with their &lt;td&gt; cells enables screen <br /> readers to announce the header prior to the data. This considerably increases the accessibility of tables to visually impaired users. <br /> There are two ways of doing it: <br />  <br />    Adding a scope attribute to &lt;th&gt; headers.  <br />    Adding an id attribute to &lt;th&gt; headers and a headers attribute to every &lt;td&gt; <br />   element.  <br />  <br /> It is recommended to add scope attributes to &lt;th&gt; headers whenever possible. Use &lt;th id="..."&gt; <br /> and &lt;td headers="..."&gt; only when &lt;th scope="..."&gt; is not capable of associating cells to their headers. This <br /> happens for very complex tables which have headers splitting the data in multiple subtables. See&nbsp;W3C WAI&nbsp;Web Accessibility Tutorials&nbsp;for more information. <br /> Note that complex tables can often be split into multiple smaller tables, which improves the user experience. <br /> This rule raises an issue when a &lt;th&gt; element has neither id nor scope attributes set. <br /> Noncompliant Code Example <br />  <br /> &lt;table border="1"&gt; <br />   &lt;caption&gt;Contact Information&lt;/caption&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;&lt;/td&gt; <br />     &lt;th&gt;Name&lt;/th&gt;                                          &lt;!-- Non-Compliant --&gt; <br />     &lt;th&gt;Phone#&lt;/th&gt;                                        &lt;!-- Non-Compliant --&gt; <br />     &lt;th&gt;City&lt;/th&gt;                                          &lt;!-- Non-Compliant --&gt; <br />   &lt;/tr&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;1.&lt;/td&gt; <br />     &lt;th&gt;Joel Garner&lt;/th&gt;                                   &lt;!-- Non-Compliant --&gt; <br />     &lt;td&gt;412-212-5421&lt;/td&gt; <br />     &lt;td&gt;Pittsburgh&lt;/td&gt; <br />   &lt;/tr&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;2.&lt;/td&gt; <br />     &lt;th&gt;Clive Lloyd&lt;/th&gt;                                   &lt;!-- Non-Compliant --&gt; <br />     &lt;td&gt;410-306-1420&lt;/td&gt; <br />     &lt;td&gt;Baltimore&lt;/td&gt; <br />   &lt;/tr&gt; <br /> &lt;/table&gt; <br />  <br /> Compliant Solution <br />  <br /> &lt;table border="1"&gt; <br />   &lt;caption&gt;Contact Information&lt;/caption&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;&lt;/td&gt; <br />     &lt;th scope="col"&gt;Name&lt;/th&gt;                              &lt;!-- Compliant --&gt; <br />     &lt;th scope="col"&gt;Phone#&lt;/th&gt;                            &lt;!-- Compliant --&gt; <br />     &lt;th scope="col"&gt;City&lt;/th&gt;                              &lt;!-- Compliant --&gt; <br />   &lt;/tr&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;1.&lt;/td&gt; <br />     &lt;th scope="row"&gt;Joel Garner&lt;/th&gt;                       &lt;!-- Compliant --&gt; <br />     &lt;td&gt;412-212-5421&lt;/td&gt; <br />     &lt;td&gt;Pittsburgh&lt;/td&gt; <br />   &lt;/tr&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;2.&lt;/td&gt; <br />     &lt;th scope="row"&gt;Clive Lloyd&lt;/th&gt;                       &lt;!-- Compliant --&gt; <br />     &lt;td&gt;410-306-1420&lt;/td&gt; <br />     &lt;td&gt;Baltimore&lt;/td&gt; <br />   &lt;/tr&gt; <br /> &lt;/table&gt; <br />  <br /> or: <br />  <br /> &lt;table border="1"&gt; <br />   &lt;caption&gt;Contact Information&lt;/caption&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;&lt;/td&gt; <br />     &lt;th id="name"&gt;Name&lt;/th&gt;                                &lt;!-- Compliant --&gt; <br />     &lt;th id="phone"&gt;Phone#&lt;/th&gt;                             &lt;!-- Compliant --&gt; <br />     &lt;th id="city"&gt;City&lt;/th&gt;                                &lt;!-- Compliant --&gt; <br />   &lt;/tr&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;1.&lt;/td&gt; <br />     &lt;th id="person1" headers="name"&gt;Joel Garner&lt;/th&gt;       &lt;!-- Compliant --&gt; <br />     &lt;td headers="phone person1"&gt;412-212-5421&lt;/td&gt; <br />     &lt;td headers="city person1"&gt;Pittsburgh&lt;/td&gt; <br />   &lt;/tr&gt; <br />   &lt;tr&gt; <br />     &lt;td&gt;2.&lt;/td&gt; <br />     &lt;th id="person2" headers="name"&gt;Clive Lloyd&lt;/th&gt;       &lt;!-- Compliant --&gt; <br />     &lt;td headers="phone person2"&gt;410-306-1420&lt;/td&gt; <br />     &lt;td headers="city person2"&gt;Baltimore&lt;/td&gt; <br />   &lt;/tr&gt; <br /> &lt;/table&gt; <br />  <br /> See <br />  * WCAG2, 1.3.1&nbsp;-&nbsp;Info <br /> and Relationships <br />  <br />    WCAG2, H43 - Using id and headers attributes to associate data cells with header <br />   cells in data tables  <br /> |BUG|MAJOR|11
Non-serializable objects should not be stored in "HttpSession" objects|If you have no intention of writting an HttpSession object to file, then storing non-serializable objects in it may not <br /> seem like a big deal. But whether or not you explicitly serialize the session, it may be written to disk anyway, as the server manages its memory use <br /> in a process called "passivation". Further, some servers automatically write their active sessions out to file at shutdown &amp; deserialize any such <br /> sessions at startup. <br /> The point is, that even though HttpSession does not extend Serializable, you must nonetheless assume that it will be <br /> serialized, and understand that if you've stored non-serializable objects in the session, errors will result.  <br /> Noncompliant Code Example <br />  <br /> public class Address { <br />   //... <br /> } <br />  <br /> //... <br /> HttpSession session = request.getSession(); <br /> session.setAttribute("address", new Address());  // Noncompliant; Address isn't serializable <br />  <br /> See <br />  <br />    MITRE, CWE-579 - J2EE Bad Practices: Non-serializable Object Stored in Session <br />    <br /> |BUG|MAJOR|4
"<table>" tags should have a description|In order to be accessible to visually impaired users, it is important that tables provides a description of its content before the data is <br /> accessed. <br /> The simplest way to do it, and also the one recommended by WCAG2 is to add a <br /> &lt;caption&gt; element inside the &lt;table&gt;. <br /> Other technics this rule accepts are: <br />  <br />    referencing the description element with an aria-describedby attribute in the &lt;table&gt;.  <br />    embedding the &lt;table&gt; inside a &lt;figure&gt; which also contains a &lt;figcaption&gt;.  <br />    adding a summary attribute to the &lt;table&gt; tag. However note that this attribute has been deprecated in HTML5. <br />    <br />  <br /> See&nbsp;W3C WAI&nbsp;Web Accessibility Tutorials&nbsp;for more information. <br /> This rule raises an issue when a &lt;table&gt; has neither of the previously mentioned description mechanisms. <br /> Noncompliant Code Example <br />  <br /> &lt;table&gt; &lt;!-- Noncompliant --&gt; <br />   ... <br /> &lt;table&gt; <br />  <br /> Compliant Solution <br /> Adding a &lt;caption&gt; element. <br />  <br /> &lt;table&gt; <br />   &lt;caption&gt;New York City Marathon Results 2013&lt;/caption&gt; <br />   ... <br /> &lt;/table&gt; <br />  <br /> Adding an aria-describedby attribute. <br />  <br /> &lt;p id="mydesc"&gt;New York City Marathon Results 2013&lt;/p&gt; <br /> &lt;table aria-describedby="mydesc"&gt; <br />   ... <br /> &lt;/table&gt; <br />  <br /> Embedding the table in a &lt;figure&gt; which also contains a &lt;figcaption&gt;. <br />  <br /> &lt;figure&gt; <br />   &lt;figcaption&gt;New York City Marathon Results 2013&lt;/figcaption&gt; <br />   &lt;table&gt; <br />     ... <br />   &lt;/table&gt; <br /> &lt;/figure&gt; <br />  <br /> Adding a summary attribute. <br />  <br /> &lt;table summary="New York City Marathon Results 2013"&gt; <br />   ... <br /> &lt;/table&gt; <br />  <br /> Exceptions <br /> No issue will be raised on &lt;table&gt; used for layout purpose, i.e. when it contains a role attribute set to <br /> "presentation" or "none". Note that using &lt;table&gt; for layout purpose is a bad practice. <br /> No issue will be raised either on &lt;table&gt; containing an aria-hidden attribute set to "true". <br /> See <br />  <br />    WCAG2, 1.3.1&nbsp;-&nbsp;Info <br />   and Relationships  <br />    WCAG2,&nbsp;H39 - Using caption elements to associate data table captions with data tables <br />    <br /> |BUG|MINOR|3
Method parameters, caught exceptions and foreach variables' initial values should not be ignored|While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug. <br /> Instead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as final, then at least read <br /> before reassignment. <br /> Noncompliant Code Example <br />  <br /> public void doTheThing(String str, int i, List&lt;String&gt; strings) { <br />   str = Integer.toString(i); // Noncompliant <br />  <br />   for (String s : strings) { <br />     s = "hello world"; // Noncompliant <br />   } <br /> } <br /> |BUG|MINOR|1
Methods and field names should not be the same or differ only by capitalization|Looking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is <br /> confusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field <br /> with exactly the same name and visibility. <br /> In the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead <br /> added a new method with nearly the same name. <br /> Otherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the <br /> case where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be <br /> disruptive to callers. Therefore renaming the member is the recommended action. <br /> Noncompliant Code Example <br />  <br /> public class Car{ <br />  <br />   public DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // Noncompliant; duplicates field name <br /> } <br />  <br /> public class MyCar extends Car{ <br />   public void teardown(){...}  // Noncompliant; not an override. It it really what's intended? <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveFast(){...} //Huh? <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Car{ <br />  <br />   private DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // field visibility reduced <br /> } <br />  <br /> public class MyCar extends Car{ <br />   @Override <br />   public void tearDown(){...} <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveReallyFast(){...} <br />  <br /> } <br /> |CODE_SMELL|BLOCKER|2
Tests should include assertions|A test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the <br /> code under test. <br /> This rule raises an exception when no assertions from any of the following known frameworks are found in a test: <br />  <br />    JUnit  <br />    Fest 1.x  <br />    Fest 2.x  <br />    Rest-assured 2.0  <br />    AssertJ  <br />    Hamcrest  <br />    Spring's org.springframework.test.web.servlet.ResultActions.andExpect()  <br />    Eclipse Vert.x  <br />    Truth Framework  <br />    Mockito  <br />    EasyMock  <br />    JMock  <br />    WireMock  <br />    RxJava 1.x  <br />    RxJava 2.x  <br />    Selenide  <br />    JMockit  <br />  <br /> Furthermore, as new or custom assertion frameworks may be used, the rule can be parametrized to define specific methods that will also be <br /> considered as assertions. No issue will be raised when such methods are found in test cases. The parameter value should have the following format <br /> &lt;FullyQualifiedClassName&gt;#&lt;MethodName&gt;, where MethodName can end with the wildcard character. For constructors, <br /> the pattern should be &lt;FullyQualifiedClassName&gt;#&lt;init&gt;. <br /> Example:&nbsp;com.company.CompareToTester#compare*,com.company.CustomAssert#customAssertMethod,com.company.CheckVerifier#&lt;init&gt;. <br /> Noncompliant Code Example <br />  <br /> @Test <br /> public void testDoSomething() {  // Noncompliant <br />   MyClass myClass = new MyClass(); <br />   myClass.doSomething(); <br /> } <br />  <br /> Compliant Solution <br /> Example when com.company.CompareToTester#compare* is used as parameter to the rule. <br />  <br /> import com.company.CompareToTester; <br />  <br /> @Test <br /> public void testDoSomething() { <br />   MyClass myClass = new MyClass(); <br />   assertNull(myClass.doSomething());  // JUnit assertion <br />   assertThat(myClass.doSomething()).isNull();  // Fest assertion <br /> } <br />  <br /> @Test <br /> public void testDoSomethingElse() { <br />   MyClass myClass = new MyClass(); <br />   new CompareToTester().compareWith(myClass);  // Compliant - custom assertion method defined as rule parameter <br />   CompareToTester.compareStatic(myClass);  // Compliant <br /> } <br /> |CODE_SMELL|BLOCKER|10
Methods should not be empty|There are several reasons for a method not to have a method body: <br />  <br />    It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production.  <br />    It is not yet, or never will be, supported. In this case an UnsupportedOperationException should be thrown.  <br />    The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.  <br />  <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br /> } <br />  <br /> public void doSomethingElse() { <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public void doSomething() { <br />   // Do nothing because of X and Y. <br /> } <br />  <br /> @Override <br /> public void doSomethingElse() { <br />   throw new UnsupportedOperationException(); <br /> } <br />  <br /> Exceptions <br /> Default (no-argument) constructors are ignored when there are other constructors in the class, as are empty methods in abstract classes. <br />  <br /> public abstract class Animal { <br />   void speak() {  // default implementation ignored <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|4
String literals should not be duplicated|Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences. <br /> On the other hand, constants can be referenced from many places, but only need to be updated in a single place. <br /> Noncompliant Code Example <br /> With the default threshold of 3: <br />  <br /> public void run() { <br />   prepare("action1");                              // Noncompliant - "action1" is duplicated 3 times <br />   execute("action1"); <br />   release("action1"); <br /> } <br />  <br /> @SuppressWarning("all")                            // Compliant - annotations are excluded <br /> private void method1() { /* ... */ } <br /> @SuppressWarning("all") <br /> private void method2() { /* ... */ } <br />  <br /> public String method3(String a) { <br />   System.out.println("'" + a + "'");               // Compliant - literal "'" has less than 5 characters and is excluded <br />   return "";                                       // Compliant - literal "" has less than 5 characters and is excluded <br /> } <br />  <br /> Compliant Solution <br />  <br /> private static final String ACTION_1 = "action1";  // Compliant <br />  <br /> public void run() { <br />   prepare(ACTION_1);                               // Compliant <br />   execute(ACTION_1); <br />   release(ACTION_1); <br /> } <br />  <br /> Exceptions <br /> To prevent generating some false-positives, literals having less than 5 characters are excluded.|CODE_SMELL|CRITICAL|5
Cognitive Complexity of methods should not be too high|Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be <br /> difficult to maintain. <br /> See <br />  <br />    Cognitive Complexity  <br /> |CODE_SMELL|CRITICAL|2
Track uses of "TODO" tags|TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later. <br /> Sometimes the developer will not have the time or will simply forget to get back to that tag. <br /> This rule is meant to track those tags and to ensure that they do not go unnoticed. <br /> See <br />  <br />    MITRE, CWE-546 - Suspicious Comment  <br /> |CODE_SMELL|INFO|4
Track uses of "TODO" tags|TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later. <br /> Sometimes the developer will not have the time or will simply forget to get back to that tag. <br /> This rule is meant to track those tags and to ensure that they do not go unnoticed. <br /> Noncompliant Code Example <br />  <br /> void doSomething() { <br />   // TODO <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-546 - Suspicious Comment  <br /> |CODE_SMELL|INFO|5
Sections of code should not be commented out|Programmers should not comment out code as it bloats programs and reduces readability. <br /> Unused code should be deleted and can be retrieved from source control history if required.|CODE_SMELL|MAJOR|8
Nested blocks of code should not be left empty|Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed. <br /> Noncompliant Code Example <br />  <br /> for (int i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ? <br />  <br /> Exceptions <br /> When a block contains a comment, this block is not considered to be empty unless it is a synchronized block. synchronized <br /> blocks are still considered empty even with comments because they can still affect program flow.|CODE_SMELL|MAJOR|1
Generic exceptions should never be thrown|Using such generic exceptions as Error, RuntimeException, Throwable, and Exception prevents <br /> calling methods from handling true, system-generated exceptions differently than application-generated errors.  <br /> Noncompliant Code Example <br />  <br /> public void foo(String bar) throws Throwable {  // Noncompliant <br />   throw new RuntimeException("My Message");     // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo(String bar) { <br />   throw new MyOwnRuntimeException("My Message"); <br /> } <br />  <br /> Exceptions <br /> Generic exceptions in the signatures of overriding methods are ignored, because overriding method has to follow signature of the throw declaration <br /> in the superclass. The issue will be raised on superclass declaration of the method (or won't be raised at all if superclass is not part of the <br /> analysis). <br />  <br /> @Override <br /> public void myMethod() throws Exception {...} <br />  <br /> Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions. <br />  <br /> public void myOtherMethod throws Exception { <br />   doTheThing();  // this method throws Exception <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-397 - Declaration of Throws for Generic Exception  <br />    CERT, ERR07-J. - Do not throw RuntimeException, Exception, or Throwable <br />    <br /> |CODE_SMELL|MAJOR|1
Utility classes should not have public constructors|Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can <br /> be extended, should not have public constructors. <br /> Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor <br /> should be defined. <br /> Noncompliant Code Example <br />  <br /> class StringUtils { // Noncompliant <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class StringUtils { // Compliant <br />  <br />   private StringUtils() { <br />     throw new IllegalStateException("Utility class"); <br />   } <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> When class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this <br /> rule.|CODE_SMELL|MAJOR|1
Try-catch blocks should not be nested|Nesting try/catch blocks severely impacts the readability of source code because it makes it too difficult to understand <br /> which block will catch which exception.|CODE_SMELL|MAJOR|3
Empty arrays and collections should be returned instead of null|Returning null instead of an actual array or collection forces callers of the method to explicitly test for nullity, making them more <br /> complex and less readable. <br /> Moreover, in many cases, null is used as a synonym for empty. <br /> Noncompliant Code Example <br />  <br /> public static List&lt;Result&gt; getResults() { <br />   return null;                             // Noncompliant <br /> } <br />  <br /> public static Result[] getResults() { <br />   return null;                             // Noncompliant <br /> } <br />  <br /> public static void main(String[] args) { <br />   Result[] results = getResults(); <br />  <br />   if (results != null) {                   // Nullity test required to prevent NPE <br />     for (Result result: results) { <br />       /* ... */ <br />     } <br />   } <br /> } <br />  <br />  <br /> Compliant Solution <br />  <br /> public static List&lt;Result&gt; getResults() { <br />   return Collections.emptyList();          // Compliant <br /> } <br />  <br /> public static Result[] getResults() { <br />   return new Result[0]; <br /> } <br />  <br /> public static void main(String[] args) { <br />   for (Result result: getResults()) { <br />     /* ... */ <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, MSC19-C. - For functions that return an array, prefer returning an <br />   empty array over a null value  <br />    CERT, MET55-J. - Return an empty array or collection instead of a null <br />   value for methods that return an array or collection  <br /> |CODE_SMELL|MAJOR|2
Unused method parameters should be removed|Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same. <br /> Noncompliant Code Example <br />  <br /> void doSomething(int a, int b) {     // "b" is unused <br />   compute(a); <br /> } <br />  <br /> Compliant Solution <br />  <br /> void doSomething(int a) { <br />   compute(a); <br /> } <br />  <br /> Exceptions <br /> The rule will not raise issues for unused parameters: <br />  <br />    that are annotated with @javax.enterprise.event.Observes  <br />    in overrides and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw or that have empty bodies  <br />    in annotated methods, unless the annotation is @SuppressWarning("unchecked") or @SuppressWarning("rawtypes"), in <br />   which case the annotation will be ignored  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the parameter is documented with a proper <br />   javadoc.  <br />  <br />  <br /> @Override <br /> void doSomething(int a, int b) {     // no issue reported on b <br />   compute(a); <br /> } <br />  <br /> public void foo(String s) { <br />   // designed to be extended but noop in standard case <br /> } <br />  <br /> protected void bar(String s) { <br />   //open-closed principle <br /> } <br />  <br /> public void qix(String s) { <br />   throw new UnsupportedOperationException("This method should be implemented in subclasses"); <br /> } <br />  <br /> /** <br />  * @param s This string may be use for further computation in overriding classes <br />  */ <br /> protected void foobar(int a, String s) { // no issue, method is overridable and unused parameter has proper javadoc <br />   compute(a); <br /> } <br />  <br /> See <br />  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br /> |CODE_SMELL|MAJOR|2
Dead stores should be removed|A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value <br /> only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources. <br /> Therefore all calculated values should be used. <br /> Noncompliant Code Example <br />  <br /> i = a + b; // Noncompliant; calculation result not used before value is overwritten <br /> i = compute(); <br />  <br /> Compliant Solution <br />  <br /> i = a + b; <br /> i += compute(); <br />  <br /> Exceptions <br /> This rule ignores initializations to -1, 0, 1, null, true, false and "". <br /> See <br />  <br />    MITRE, CWE-563 - Assignment to Variable without Use ('Unused Variable')  <br />    CERT, MSC13-C. - Detect and remove unused values  <br />    CERT, MSC56-J. - Detect and remove superfluous code and values  <br /> |CODE_SMELL|MAJOR|7
Static fields should not be updated in constructors|Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all <br /> instances of the class. <br /> Instead remove the field's static modifier, or initialize it statically. <br /> Noncompliant Code Example <br />  <br /> public class Person { <br />   static Date dateOfBirth; <br />   static int expectedFingers; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday <br />     expectedFingers = 10;  // Noncompliant <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Person { <br />   Date dateOfBirth; <br />   static int expectedFingers = 10; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday; <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|1
Empty statements should be removed|Empty statements, i.e. ;, are usually introduced by mistake, for example because: <br />  <br />    It was meant to be replaced by an actual statement, but this was forgotten.  <br />    There was a typo which lead the semicolon to be doubled, i.e. ;;.  <br />  <br /> Noncompliant Code Example <br />  <br /> void doSomething() { <br />   ;                                                       // Noncompliant - was used as a kind of TODO marker <br /> } <br />  <br /> void doSomethingElse() { <br />   System.out.println("Hello, world!");;                     // Noncompliant - double ; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> void doSomething() {} <br />  <br /> void doSomethingElse() { <br />   System.out.println("Hello, world!"); <br />   ... <br />   for (int i = 0; i &lt; 3; i++) ; // compliant if unique statement of a loop <br />   ... <br /> } <br />  <br /> See <br />  <br />    CERT, MSC12-C. - Detect and remove code that has no effect or is never <br />   executed  <br />    CERT, MSC51-J. - Do not place a semicolon immediately following an if, for, <br />   or while condition  <br />    CERT, EXP15-C. - Do not place a semicolon on the same line as an if, for, <br />   or while statement  <br /> |CODE_SMELL|MINOR|1
"throws" declarations should not be superfluous|An exception in a throws declaration in Java is superfluous if it is: <br />  <br />    listed multiple times  <br />    a subclass of another listed exception  <br />    a RuntimeException, or one of its descendants  <br />    completely unnecessary because the declared exception type cannot actually be thrown  <br />  <br /> Noncompliant Code Example <br />  <br /> void foo() throws MyException, MyException {}  // Noncompliant; should be listed once <br /> void bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable <br /> void baz() throws RuntimeException {}  // Noncompliant; RuntimeException can always be thrown <br />  <br /> Compliant Solution <br />  <br /> void foo() throws MyException {} <br /> void bar() throws Throwable {} <br /> void baz() {} <br />  <br /> Exceptions <br /> The rule will not raise any issue for exceptions that cannot be thrown from the method body: <br />  <br />    in overriding and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw, have empty bodies, or a single return statement .  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper <br />   javadoc.  <br />  <br />  <br /> class A extends B { <br />   @Override <br />   void doSomething() throws IOException { <br />     compute(a); <br />   } <br />  <br />   public void foo() throws IOException {} <br />  <br />   protected void bar() throws IOException { <br />     throw new UnsupportedOperationException("This method should be implemented in subclasses"); <br />   } <br />  <br />   Object foobar(String s) throws IOException { <br />     return null; <br />   } <br />  <br />   /** <br />    * @throws IOException Overriding classes may throw this exception if they print values into a file <br />    */ <br />   protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc <br />     System.out.println("foo"); <br />   } <br /> } <br /> |CODE_SMELL|MINOR|9
Field names should comply with a naming convention|Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field <br /> names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> class MyClass { <br />    private int my_field; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private int myField; <br /> } <br /> |CODE_SMELL|MINOR|3
Local variable and method parameter names should comply with a naming convention|Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does <br /> not match the provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public void doSomething(int my_param) { <br />   int LOCAL; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(int myParam) { <br />   int local; <br />   ... <br /> } <br />  <br /> Exceptions <br /> Loop counters are ignored by this rule. <br />  <br /> for (int i_1 = 0; i_1 &lt; limit; i_1++) {  // Compliant <br />   // ... <br /> } <br />  <br /> as well as one-character catch variables:  <br />  <br /> try { <br /> //... <br /> } catch (Exception e) { // Compliant <br /> } <br /> |CODE_SMELL|MINOR|5
Collection.isEmpty() should be used to test for emptiness|Using Collection.size() to test for emptiness works, but using Collection.isEmpty() makes the code more readable and can <br /> be more performant. The time complexity of any isEmpty() method implementation should be O(1) whereas some implementations <br /> of size() can be O(n). <br /> Noncompliant Code Example <br />  <br /> if (myCollection.size() == 0) {  // Noncompliant <br />   /* ... */ <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (myCollection.isEmpty()) { <br />   /* ... */ <br /> } <br /> |CODE_SMELL|MINOR|1
Declarations should use Java collection interfaces such as "List" rather than specific implementation classes such as "LinkedList"|The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details. <br /> Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose <br /> type is a Java Collection interface. <br /> This rule raises an issue when an implementation class: <br />  <br />    is returned from a public method.  <br />    is accepted as an argument to a public method.  <br />    is exposed as a public member.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Employees { <br />   private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();  // Noncompliant - "employees" should have type "Set" rather than "HashSet" <br />  <br />   public HashSet&lt;Employee&gt; getEmployees() {                       // Noncompliant <br />     return employees; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Employees { <br />   private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();      // Compliant <br />  <br />   public Set&lt;Employee&gt; getEmployees() {                           // Compliant <br />     return employees; <br />   } <br /> } <br /> |CODE_SMELL|MINOR|6
Unused local variables should be removed|If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will <br /> not wonder what the variable is used for. <br /> Noncompliant Code Example <br />  <br /> public int numberOfMinutes(int hours) { <br />   int seconds = 0;   // seconds is never used <br />   return hours * 60; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public int numberOfMinutes(int hours) { <br />   return hours * 60; <br /> } <br /> |CODE_SMELL|MINOR|9
Local variables should not be declared and then immediately returned or thrown|Declaring a variable only to immediately return or throw it is a bad practice. <br /> Some developers argue that the practice improves code readability, because it enables them to explicitly name what is being returned. However, this <br /> variable is an internal implementation detail that is not exposed to the callers of the method. The method name should be sufficient for callers to <br /> know exactly what will be returned. <br /> Noncompliant Code Example <br />  <br /> public long computeDurationInMilliseconds() { <br />   long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; <br />   return duration; <br /> } <br />  <br /> public void doSomething() { <br />   RuntimeException myException = new RuntimeException(); <br />   throw myException; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public long computeDurationInMilliseconds() { <br />   return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ; <br /> } <br />  <br /> public void doSomething() { <br />   throw new RuntimeException(); <br /> } <br /> |CODE_SMELL|MINOR|2
Multiple variables should not be declared on the same line|Declaring multiple variables on one line is difficult to read. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />  <br />   private int a, b; <br />  <br />   public void method(){ <br />     int c; int d; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />  <br />   private int a; <br />   private int b; <br />  <br />   public void method(){ <br />     int c; <br />     int d; <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, DCL52-J. - Do not declare more than one variable per declaration <br />    <br />    CERT, DCL04-C. - Do not declare more than one variable per declaration  <br /> |CODE_SMELL|MINOR|5
Unnecessary imports should be removed|The imports part of a file should be handled by the Integrated Development Environment (IDE), not manually by the developer.  <br /> Unused and useless imports should not occur if that is the case.  <br /> Leaving them in reduces the code's readability, since their presence can be confusing. <br /> Noncompliant Code Example <br />  <br /> package my.company; <br />  <br /> import java.lang.String;        // Noncompliant; java.lang classes are always implicitly imported <br /> import my.company.SomeClass;    // Noncompliant; same-package files are always implicitly imported <br /> import java.io.File;            // Noncompliant; File is not used <br />  <br /> import my.company2.SomeType; <br /> import my.company2.SomeType;    // Noncompliant; 'SomeType' is already imported <br />  <br /> class ExampleClass { <br />  <br />   public String someString; <br />   public SomeType something; <br />  <br /> } <br />  <br /> Exceptions <br /> Imports for types mentioned in comments, such as Javadocs, are ignored.|CODE_SMELL|MINOR|18
Formatting SQL queries is security-sensitive|Formatting strings used as SQL queries is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2018-9019  <br />    CVE-2018-7318  <br />    CVE-2017-5611  <br />  <br /> SQL queries often need to use a hardcoded SQL string with a dynamic parameter coming from a user request. Formatting a string to add those <br /> parameters to the request is a bad practice as it can result in an SQL injection. The safe <br /> way to add parameters to a SQL query is to use SQL binding mechanisms. <br /> This rule raises an issue when an SQL query is built by formatting Strings, even if there is no injection. This rule does not detect SQL <br /> injections. The goal is to guide security code reviews and to prevent a common bad practice. <br /> The following method signatures from Java JDBC, JPA, JDO, Hibernate and Spring are tested:  <br />  <br />    org.hibernate.Session.createQuery  <br />    org.hibernate.Session.createSQLQuery  <br />    java.sql.Statement.executeQuery  <br />    java.sql.Statement.execute  <br />    java.sql.Statement.executeUpdate  <br />    java.sql.Statement.executeLargeUpdate  <br />    java.sql.Statement.addBatch  <br />    java.sql.Connection.prepareStatement  <br />    java.sql.Connection.prepareCall  <br />    java.sql.Connection.nativeSQL  <br />    javax.persistence.EntityManager.createNativeQuery  <br />    javax.persistence.EntityManager.createQuery  <br />    org.springframework.jdbc.core.JdbcOperations.batchUpdate  <br />    org.springframework.jdbc.core.JdbcOperations.execute  <br />    org.springframework.jdbc.core.JdbcOperations.query  <br />    org.springframework.jdbc.core.JdbcOperations.queryForList  <br />    org.springframework.jdbc.core.JdbcOperations.queryForMap  <br />    org.springframework.jdbc.core.JdbcOperations.queryForObject  <br />    org.springframework.jdbc.core.JdbcOperations.queryForRowSet  <br />    org.springframework.jdbc.core.JdbcOperations.queryForInt  <br />    org.springframework.jdbc.core.JdbcOperations.queryForLong  <br />    org.springframework.jdbc.core.JdbcOperations.update  <br />    org.springframework.jdbc.core.PreparedStatementCreatorFactory.&lt;init&gt;  <br />    org.springframework.jdbc.core.PreparedStatementCreatorFactory.newPreparedStatementCreator  <br />    javax.jdo.PersistenceManager.newQuery  <br />    javax.jdo.Query.setFilter  <br />    javax.jdo.Query.setGrouping  <br />  <br /> If a method is defined in an interface, implementations are also tested. For example this is the case for <br /> org.springframework.jdbc.core.JdbcOperations , which is usually used as org.springframework.jdbc.core.JdbcTemplate).  <br /> Ask Yourself Whether <br />  <br />    the SQL query is built using string formatting technics, such as concatenating variables.  <br />    some of the values are coming from an untrusted source and are not sanitized.  <br />  <br /> You may be at risk if you answered yes to this question. <br /> Recommended Secure Coding Practices <br />  <br />    Avoid building queries manually using formatting technics. If you do it anyway, do not include user input in this building process.  <br />    Use parameterized queries, prepared statements, or stored <br />   procedures whenever possible.  <br />    You may also use ORM frameworks such as Hibernate which, if used correctly, reduce injection risks.  <br />    Avoid executing SQL queries containing unsafe input in stored procedures or functions.  <br />    Sanitize every unsafe input.  <br />  <br /> You can also reduce the impact of an attack by using a database account with low privileges. <br /> Sensitive Code Example <br />  <br /> public User getUser(Connection con, String user) throws SQLException { <br />  <br />   Statement stmt1 = null; <br />   Statement stmt2 = null; <br />   PreparedStatement pstmt; <br />   try { <br />     stmt1 = con.createStatement(); <br />     ResultSet rs1 = stmt1.executeQuery("GETDATE()"); // No issue; hardcoded query <br />  <br />     stmt2 = con.createStatement(); <br />     ResultSet rs2 = stmt2.executeQuery("select FNAME, LNAME, SSN " + <br />                  "from USERS where UNAME=" + user);  // Sensitive <br />  <br />     pstmt = con.prepareStatement("select FNAME, LNAME, SSN " + <br />                  "from USERS where UNAME=" + user);  // Sensitive <br />     ResultSet rs3 = pstmt.executeQuery(); <br />  <br />     //... <br /> } <br />  <br /> public User getUserHibernate(org.hibernate.Session session, String data) { <br />  <br />   org.hibernate.Query query = session.createQuery( <br />             "FROM students where fname = " + data);  // Sensitive <br />   // ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public User getUser(Connection con, String user) throws SQLException { <br />  <br />   Statement stmt1 = null; <br />   PreparedStatement pstmt = null; <br />   String query = "select FNAME, LNAME, SSN " + <br />                  "from USERS where UNAME=?" <br />   try { <br />     stmt1 = con.createStatement(); <br />     ResultSet rs1 = stmt1.executeQuery("GETDATE()"); <br />  <br />     pstmt = con.prepareStatement(query); <br />     pstmt.setString(1, user);  // Good; PreparedStatements escape their inputs. <br />     ResultSet rs2 = pstmt.executeQuery(); <br />  <br />     //... <br />   } <br /> } <br />  <br /> public User getUserHibernate(org.hibernate.Session session, String data) { <br />  <br />   org.hibernate.Query query =  session.createQuery("FROM students where fname = ?"); <br />   query = query.setParameter(0,data);  // Good; Parameter binding escapes all input <br />  <br />   org.hibernate.Query query2 =  session.createQuery("FROM students where fname = " + data); // Sensitive <br />   // ... <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A1 - Injection  <br />    MITRE, CWE-89 - Improper Neutralization of Special Elements used in an SQL Command  <br />    MITRE, CWE-564 - SQL Injection: Hibernate  <br />    MITRE, CWE-20 - Improper Input Validation  <br />    MITRE, CWE-943 - Improper Neutralization of Special Elements in Data Query Logic <br />    <br />    CERT, IDS00-J. - Prevent SQL injection  <br />    SANS Top 25 - Insecure Interaction Between Components  <br />    Derived from FindSecBugs rules Potential SQL/JPQL Injection <br />   (JPA), Potential SQL/JDOQL Injection (JDO), Potential SQL/HQL Injection (Hibernate)  <br /> |SECURITY_HOTSPOT|CRITICAL|5
Hashing data is security-sensitive|Hashing data is security-sensitive. It has led in the past to the following vulnerabilities: <br />  <br />    CVE-2018-9233  <br />    CVE-2013-5097  <br />    CVE-2007-1051  <br />  <br /> Cryptographic hash functions are used to uniquely identify information without storing their original form. When not done properly, an attacker can <br /> steal the original information by guessing it (ex: with a rainbow table), or replace the <br /> original data with another one having the same hash. <br /> This rule flags code that initiates hashing. <br /> Ask Yourself Whether <br />  <br />    the hashed value is used in a security context.  <br />    the hashing algorithm you are using is known to have vulnerabilities.  <br />    salts are not automatically generated and applied by the hashing function. <br />    <br />    any generated salts are cryptographically weak or not credential-specific.  <br />  <br /> You are at risk if you answered yes to the first question and any of the following ones. <br /> Recommended Secure Coding Practices <br />  <br />    for security related purposes, use only hashing algorithms which are currently known to be strong. Avoid using algorithms like MD5 and SHA1 <br />   completely in security contexts.  <br />    do not define your own hashing- or salt algorithms as they will most probably have flaws.  <br />    do not use algorithms that compute too quickly, like SHA256, as it must remain beyond modern hardware capabilities to perform brute force and <br />   dictionary based attacks.  <br />    use a hashing algorithm that generate its own salts as part of the hashing. If you generate your own salts, make sure that a cryptographically <br />   strong salt algorithm is used, that generated salts are credential-specific, and finally, that the salt is applied correctly before the hashing. <br />    <br />    save both the salt and the hashed value in the relevant database record; during future validation operations, the salt and hash can then be <br />   retrieved from the database. The hash is recalculated with the stored salt and the value being validated, and the result compared to the stored <br />   hash.  <br />    the strength of hashing algorithms often decreases over time as hardware capabilities increase. Check regularly that the algorithms you are <br />   using are still considered secure. If needed, rehash your data using a stronger algorithm.  <br />  <br /> Sensitive Code Example <br />  <br /> // === MessageDigest === <br /> import java.security.MessageDigest; <br /> import java.security.Provider; <br />  <br /> class A { <br />     void foo(String algorithm, String providerStr, Provider provider) throws Exception { <br />         MessageDigest.getInstance(algorithm); // Sensitive <br />         MessageDigest.getInstance(algorithm, providerStr); // Sensitive <br />         MessageDigest.getInstance(algorithm, provider); // Sensitive <br />     } <br /> } <br />  <br /> Regarding SecretKeyFactory. Any call to SecretKeyFactory.getInstance("...") with an argument starting by <br /> "PBKDF2" will be highlighted. See OWASP guidelines, list of standard algorithms and algorithms on android. <br />  <br /> // === javax.crypto === <br /> import javax.crypto.spec.PBEKeySpec; <br /> import javax.crypto.SecretKeyFactory; <br />  <br /> class A { <br />     void foo(char[] password, byte[] salt, int iterationCount, int keyLength) throws Exception { <br />         // Sensitive. Review this, even if it is the way recommended by OWASP <br />         SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512"); <br />         PBEKeySpec spec = new PBEKeySpec(password, salt, iterationCount, keyLength); <br />         factory.generateSecret(spec).getEncoded(); <br />     } <br /> } <br />  <br /> Regarding Guava, only the hashing functions which are usually misused for sensitive data will raise an issue, i.e. md5 and <br /> sha*. <br />  <br /> // === Guava === <br /> import com.google.common.hash.Hashing; <br />  <br /> class A { <br />     void foo() { <br />         Hashing.md5(); // Sensitive <br />         Hashing.sha1(); // Sensitive <br />         Hashing.sha256(); // Sensitive <br />         Hashing.sha384(); // Sensitive <br />         Hashing.sha512(); // Sensitive <br />     } <br /> } <br />  <br />  <br /> // === org.apache.commons === <br /> import org.apache.commons.codec.digest.DigestUtils; <br />  <br /> class A { <br />     void foo(String strName, byte[] data, String str, java.io.InputStream stream) throws Exception { <br />         new DigestUtils(strName); // Sensitive <br />         new DigestUtils(); // Sensitive <br />  <br />         DigestUtils.getMd2Digest(); // Sensitive <br />         DigestUtils.getMd5Digest(); // Sensitive <br />         DigestUtils.getShaDigest(); // Sensitive <br />         DigestUtils.getSha1Digest(); // Sensitive <br />         DigestUtils.getSha256Digest(); // Sensitive <br />         DigestUtils.getSha384Digest(); // Sensitive <br />         DigestUtils.getSha512Digest(); // Sensitive <br />  <br />  <br />         DigestUtils.md2(data); // Sensitive <br />         DigestUtils.md2(stream); // Sensitive <br />         DigestUtils.md2(str); // Sensitive <br />         DigestUtils.md2Hex(data); // Sensitive <br />         DigestUtils.md2Hex(stream); // Sensitive <br />         DigestUtils.md2Hex(str); // Sensitive <br />  <br />         DigestUtils.md5(data); // Sensitive <br />         DigestUtils.md5(stream); // Sensitive <br />         DigestUtils.md5(str); // Sensitive <br />         DigestUtils.md5Hex(data); // Sensitive <br />         DigestUtils.md5Hex(stream); // Sensitive <br />         DigestUtils.md5Hex(str); // Sensitive <br />  <br />         DigestUtils.sha(data); // Sensitive <br />         DigestUtils.sha(stream); // Sensitive <br />         DigestUtils.sha(str); // Sensitive <br />         DigestUtils.shaHex(data); // Sensitive <br />         DigestUtils.shaHex(stream); // Sensitive <br />         DigestUtils.shaHex(str); // Sensitive <br />  <br />         DigestUtils.sha1(data); // Sensitive <br />         DigestUtils.sha1(stream); // Sensitive <br />         DigestUtils.sha1(str); // Sensitive <br />         DigestUtils.sha1Hex(data); // Sensitive <br />         DigestUtils.sha1Hex(stream); // Sensitive <br />         DigestUtils.sha1Hex(str); // Sensitive <br />  <br />         DigestUtils.sha256(data); // Sensitive <br />         DigestUtils.sha256(stream); // Sensitive <br />         DigestUtils.sha256(str); // Sensitive <br />         DigestUtils.sha256Hex(data); // Sensitive <br />         DigestUtils.sha256Hex(stream); // Sensitive <br />         DigestUtils.sha256Hex(str); // Sensitive <br />  <br />         DigestUtils.sha384(data); // Sensitive <br />         DigestUtils.sha384(stream); // Sensitive <br />         DigestUtils.sha384(str); // Sensitive <br />         DigestUtils.sha384Hex(data); // Sensitive <br />         DigestUtils.sha384Hex(stream); // Sensitive <br />         DigestUtils.sha384Hex(str); // Sensitive <br />  <br />         DigestUtils.sha512(data); // Sensitive <br />         DigestUtils.sha512(stream); // Sensitive <br />         DigestUtils.sha512(str); // Sensitive <br />         DigestUtils.sha512Hex(data); // Sensitive <br />         DigestUtils.sha512Hex(stream); // Sensitive <br />         DigestUtils.sha512Hex(str); // Sensitive <br />     } <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    OWASP Top 10 2017 Category A6 - Security <br />   Misconfiguration  <br />    MITRE, CWE-916 - Use of Password Hash With Insufficient Computational Effort <br />    <br />    MITRE, CWE-759 - Use of a One-Way Hash without a Salt  <br />    MITRE, CWE-760 - Use of a One-Way Hash with a Predictable Salt  <br />    SANS Top 25 - Porous Defenses  <br /> |SECURITY_HOTSPOT|CRITICAL|1
Throwable.printStackTrace(...) should not be called|Throwable.printStackTrace(...) prints a Throwable and its stack trace to some stream. By default that stream <br /> System.Err, which could inadvertently expose sensitive information. <br /> Loggers should be used instead to print Throwables, as they have many advantages: <br />  <br />    Users are able to easily retrieve the logs.  <br />    The format of log messages is uniform and allow users to browse the logs easily.  <br />  <br /> This rule raises an issue when printStackTrace is used without arguments, i.e. when the stack trace is printed to the default <br /> stream. <br /> Noncompliant Code Example <br />  <br /> try { <br />   /* ... */ <br /> } catch(Exception e) { <br />   e.printStackTrace();        // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> try { <br />   /* ... */ <br /> } catch(Exception e) { <br />   LOGGER.log("context", e); <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    MITRE, CWE-489 - Leftover Debug Code  <br /> |VULNERABILITY|MINOR|3
Exceptions should not be thrown from servlet methods|Even though the signatures for methods in a servlet include throws IOException, ServletException, it's a bad idea to let such <br /> exceptions be thrown. Failure to catch exceptions in a servlet could leave a system in a vulnerable state, possibly resulting in denial-of-service <br /> attacks, or the exposure of sensitive information because when a servlet throws an exception, the servlet container typically sends debugging <br /> information back to the user. And that information could be very valuable to an attacker.  <br /> This rule checks all exceptions in methods named "do*" are explicitly handled in servlet classes. <br /> Noncompliant Code Example <br />  <br /> public void doGet(HttpServletRequest request, HttpServletResponse response) <br />   throws IOException, ServletException { <br />   String ip = request.getRemoteAddr(); <br />   InetAddress addr = InetAddress.getByName(ip); // Noncompliant; getByName(String) throws UnknownHostException <br />   //... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doGet(HttpServletRequest request, HttpServletResponse response) <br />   throws IOException, ServletException { <br />   try { <br />     String ip = request.getRemoteAddr(); <br />     InetAddress addr = InetAddress.getByName(ip); <br />     //... <br />   } <br />   catch (UnknownHostException uhex) { <br />     //... <br />   } <br /> } <br />  <br /> See <br />  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data Exposure <br />    <br />    MITRE, CWE-600 - Uncaught Exception in Servlet  <br />    CERT, ERR01-J. - Do not allow exceptions to expose sensitive information <br />    <br /> |VULNERABILITY|MINOR|4
